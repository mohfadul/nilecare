{"version":3,"file":"opossum.min.js","mappings":"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","sources":["webpack://circuitBreaker/webpack/universalModuleDefinition","webpack://circuitBreaker/./node_modules/events/events.js","webpack://circuitBreaker/./lib/semaphore.js","webpack://circuitBreaker/./lib/circuit.js","webpack://circuitBreaker/./lib/cache.js","webpack://circuitBreaker/./index.js","webpack://circuitBreaker/./lib/status.js","webpack://circuitBreaker/webpack/bootstrap","webpack://circuitBreaker/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"circuitBreaker\"] = factory();\n\telse\n\t\troot[\"circuitBreaker\"] = factory();\n})(self, () => {\nreturn ","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","'use strict';\n\nmodule.exports = exports = semaphore;\n\nfunction semaphore (count) {\n  const resolvers = [];\n  let counter = count;\n\n  const sem = {\n    take,\n    release,\n    test\n  };\n\n  Object.defineProperty(sem, 'count', {\n    get: _ => counter,\n    enumerable: true\n  });\n\n  return sem;\n\n  function take (timeout) {\n    if (counter > 0) {\n      --counter;\n      return Promise.resolve(release);\n    }\n    return new Promise((resolve, reject) => {\n      resolvers.push(_ => {\n        --counter;\n        resolve(release);\n      });\n      if (timeout) {\n        setTimeout(_ => {\n          resolvers.shift();\n          const err = new Error(`Timed out after ${timeout}ms`);\n          err.code = 'ETIMEDOUT';\n          reject(err);\n        }, timeout);\n      }\n    });\n  }\n\n  function release () {\n    counter++;\n    if (resolvers.length > 0) {\n      resolvers.shift()();\n    }\n  }\n\n  function test () {\n    if (counter < 1) return false;\n    return take() && true;\n  }\n}\n","'use strict';\n\nconst EventEmitter = require('events');\nconst Status = require('./status');\nconst Semaphore = require('./semaphore');\nconst MemoryCache = require('./cache');\n\nconst STATE = Symbol('state');\nconst OPEN = Symbol('open');\nconst CLOSED = Symbol('closed');\nconst HALF_OPEN = Symbol('half-open');\nconst PENDING_CLOSE = Symbol('pending-close');\nconst SHUTDOWN = Symbol('shutdown');\nconst FALLBACK_FUNCTION = Symbol('fallback');\nconst STATUS = Symbol('status');\nconst NAME = Symbol('name');\nconst GROUP = Symbol('group');\nconst ENABLED = Symbol('Enabled');\nconst WARMING_UP = Symbol('warming-up');\nconst VOLUME_THRESHOLD = Symbol('volume-threshold');\nconst OUR_ERROR = Symbol('our-error');\nconst RESET_TIMEOUT = Symbol('reset-timeout');\nconst WARMUP_TIMEOUT = Symbol('warmup-timeout');\nconst LAST_TIMER_AT = Symbol('last-timer-at');\nconst deprecation = `options.maxFailures is deprecated. \\\nPlease use options.errorThresholdPercentage`;\n\n/**\n * Constructs a {@link CircuitBreaker}.\n *\n * @class CircuitBreaker\n * @extends EventEmitter\n * @param {Function} action The action to fire for this {@link CircuitBreaker}\n * @param {Object} options Options for the {@link CircuitBreaker}\n * @param {Status} options.status A {@link Status} object that might\n *   have pre-prime stats\n * @param {Number} options.timeout The time in milliseconds that action should\n * be allowed to execute before timing out. Timeout can be disabled by setting\n * this to `false`. Default 10000 (10 seconds)\n * @param {Number} options.maxFailures (Deprecated) The number of times the\n * circuit can fail before opening. Default 10.\n * @param {Number} options.resetTimeout The time in milliseconds to wait before\n * setting the breaker to `halfOpen` state, and trying the action again.\n * Default: 30000 (30 seconds)\n * @param {Number} options.rollingCountTimeout Sets the duration of the\n * statistical rolling window, in milliseconds. This is how long Opossum keeps\n * metrics for the circuit breaker to use and for publishing. Default: 10000\n * @param {Number} options.rollingCountBuckets Sets the number of buckets the\n * rolling statistical window is divided into. So, if\n * options.rollingCountTimeout is 10000, and options.rollingCountBuckets is 10,\n * then the statistical window will be 1000/1 second snapshots in the\n * statistical window. Default: 10\n * @param {String} options.name the circuit name to use when reporting stats.\n * Default: the name of the function this circuit controls.\n * @param {boolean} options.rollingPercentilesEnabled This property indicates\n * whether execution latencies should be tracked and calculated as percentiles.\n * If they are disabled, all summary statistics (mean, percentiles) are\n * returned as -1. Default: true\n * @param {Number} options.capacity the number of concurrent requests allowed.\n * If the number currently executing function calls is equal to\n * options.capacity, further calls to `fire()` are rejected until at least one\n * of the current requests completes. Default: `Number.MAX_SAFE_INTEGER`.\n * @param {Number} options.errorThresholdPercentage the error percentage at\n * which to open the circuit and start short-circuiting requests to fallback.\n * Default: 50\n * @param {boolean} options.enabled whether this circuit is enabled upon\n * construction. Default: true\n * @param {boolean} options.allowWarmUp determines whether to allow failures\n * without opening the circuit during a brief warmup period (this is the\n * `rollingCountTimeout` property). Default: false\n * This can help in situations where no matter what your\n * `errorThresholdPercentage` is, if the first execution times out or fails,\n * the circuit immediately opens.\n * @param {Number} options.volumeThreshold the minimum number of requests within\n * the rolling statistical window that must exist before the circuit breaker\n * can open. This is similar to `options.allowWarmUp` in that no matter how many\n * failures there are, if the number of requests within the statistical window\n * does not exceed this threshold, the circuit will remain closed. Default: 0\n * @param {Function} options.errorFilter an optional function that will be\n * called when the circuit's function fails (returns a rejected Promise). If\n * this function returns truthy, the circuit's failPure statistics will not be\n * incremented. This is useful, for example, when you don't want HTTP 404 to\n * trip the circuit, but still want to handle it as a failure case.\n * @param {boolean} options.cache whether the return value of the first\n * successful execution of the circuit's function will be cached. Once a value\n * has been cached that value will be returned for every subsequent execution:\n * the cache can be cleared using `clearCache`. (The metrics `cacheHit` and\n * `cacheMiss` reflect cache activity.) Default: false\n * @param {Number} options.cacheTTL the time to live for the cache\n * in milliseconds. Set 0 for infinity cache. Default: 0 (no TTL)\n * @param {Number} options.cacheSize the max amount of entries in the internal\n * cache. Only used when cacheTransport is not defined.\n * Default: max size of JS map (2^24).\n * @param {Function} options.cacheGetKey function that returns the key to use\n * when caching the result of the circuit's fire.\n * Better to use custom one, because `JSON.stringify` is not good\n * from performance perspective.\n * Default: `(...args) => JSON.stringify(args)`\n * @param {CacheTransport} options.cacheTransport custom cache transport\n * should implement `get`, `set` and `flush` methods.\n * @param {boolean} options.coalesce  If true, this provides coalescing of\n * requests to this breaker, in other words: the promise will be cached.\n * Only one action (with same cache key) is executed at a time, and the other\n * pending actions wait for the result. Performance will improve when rapidly\n * firing the circuitbreaker with the same request, especially on a slower\n * action (e.g. multiple end-users fetching same data from remote).\n * Will use internal cache only. Can be used in combination with options.cache.\n * The metrics `coalesceCacheHit` and `coalesceCacheMiss` are available.\n * Default: false\n * @param {Number} options.coalesceTTL the time to live for the coalescing\n * in milliseconds. Set 0 for infinity cache. Default: same as options.timeout\n * @param {Number} options.coalesceSize the max amount of entries in the\n * coalescing cache. Default: max size of JS map (2^24).\n * @param {string[]} options.coalesceResetOn when to reset the coalesce cache.\n * Options: `error`, `success`, `timeout`. Default: not set, reset using TTL.\n * @param {AbortController} options.abortController this allows Opossum to\n * signal upon timeout and properly abort your on going requests instead of\n * leaving it in the background\n * @param {boolean} options.enableSnapshots whether to enable the rolling\n * stats snapshots that opossum emits at the bucketInterval. Disable this\n * as an optimization if you don't listen to the 'snapshot' event to reduce\n * the number of timers opossum initiates.\n * @param {EventEmitter} options.rotateBucketController if you have multiple\n * breakers in your app, the number of timers across breakers can get costly.\n * This option allows you to provide an EventEmitter that rotates the buckets\n * so you can have one global timer in your app. Make sure that you are\n * emitting a 'rotate' event from this EventEmitter\n * @param {boolean} options.autoRenewAbortController Automatically recreates\n * the instance of AbortController whenever the circuit transitions to\n * 'halfOpen' or 'closed' state. This ensures that new requests are not\n * impacted by previous signals that were triggered when the circuit was 'open'.\n * Default: false\n *\n *\n * @fires CircuitBreaker#halfOpen\n * @fires CircuitBreaker#close\n * @fires CircuitBreaker#open\n * @fires CircuitBreaker#fire\n * @fires CircuitBreaker#cacheHit\n * @fires CircuitBreaker#cacheMiss\n * @fires CircuitBreaker#coalesceCacheHit\n * @fires CircuitBreaker#coalesceCacheMiss\n * @fires CircuitBreaker#reject\n * @fires CircuitBreaker#timeout\n * @fires CircuitBreaker#success\n * @fires CircuitBreaker#semaphoreLocked\n * @fires CircuitBreaker#healthCheckFailed\n * @fires CircuitBreaker#fallback\n * @fires CircuitBreaker#failure\n */\nclass CircuitBreaker extends EventEmitter {\n  /**\n   * Returns true if the provided error was generated here. It will be false\n   * if the error came from the action itself.\n   * @param {Error} error The Error to check.\n   * @returns {Boolean} true if the error was generated here\n   */\n  static isOurError (error) {\n    return !!error[OUR_ERROR];\n  }\n\n  /**\n  * Create a new Status object,\n  * helpful when you need to prime a breaker with stats\n  * @param {Object} options -\n  * @param {Number} options.rollingCountBuckets number of buckets in the window\n  * @param {Number} options.rollingCountTimeout the duration of the window\n  * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n  * @param {Object} options.stats user supplied stats\n  * @returns {Status} a new {@link Status} object\n  */\n  static newStatus (options) {\n    return new Status(options);\n  }\n\n  constructor (action, options = {}) {\n    super();\n    this.options = options;\n    this.options.timeout = options.timeout ?? 10000;\n    this.options.resetTimeout = options.resetTimeout ?? 30000;\n    this.options.errorThresholdPercentage =\n      options.errorThresholdPercentage ?? 50;\n    this.options.rollingCountTimeout = options.rollingCountTimeout ?? 10000;\n    this.options.rollingCountBuckets = options.rollingCountBuckets ?? 10;\n    this.options.rollingPercentilesEnabled =\n      options.rollingPercentilesEnabled !== false;\n    this.options.capacity = Number.isInteger(options.capacity)\n      ? options.capacity\n      : Number.MAX_SAFE_INTEGER;\n    this.options.errorFilter = options.errorFilter || (_ => false);\n    this.options.cacheTTL = options.cacheTTL ?? 0;\n    this.options.cacheGetKey = options.cacheGetKey ??\n      ((...args) => JSON.stringify(args));\n    this.options.enableSnapshots = options.enableSnapshots !== false;\n    this.options.rotateBucketController = options.rotateBucketController;\n    this.options.coalesce = !!options.coalesce;\n    this.options.coalesceTTL = options.coalesceTTL ?? this.options.timeout;\n    this.options.coalesceResetOn = options.coalesceResetOn?.filter(o => ['error', 'success', 'timeout'].includes(o)) || [];\n\n    // Set default cache transport if not provided\n    if (this.options.cache) {\n      if (this.options.cacheTransport === undefined) {\n        this.options.cacheTransport = new MemoryCache(options.cacheSize);\n      } else if (typeof this.options.cacheTransport !== 'object' ||\n        !this.options.cacheTransport.get ||\n        !this.options.cacheTransport.set ||\n        !this.options.cacheTransport.flush\n      ) {\n        throw new TypeError(\n          'options.cacheTransport should be an object with `get`, `set` and `flush` methods'\n        );\n      }\n    }\n\n    if (this.options.coalesce) {\n      this.options.coalesceCache = new MemoryCache(options.coalesceSize);\n    }\n\n    this.semaphore = new Semaphore(this.options.capacity);\n\n    // check if action is defined\n    if (!action) {\n      throw new TypeError(\n        'No action provided. Cannot construct a CircuitBreaker without an invocable action.'\n      );\n    }\n\n    if (options.autoRenewAbortController && !options.abortController) {\n      options.abortController = new AbortController();\n    }\n\n    if (options.abortController && typeof options.abortController.abort !== 'function') {\n      throw new TypeError(\n        'AbortController does not contain `abort()` method'\n      );\n    }\n\n    this[VOLUME_THRESHOLD] = Number.isInteger(options.volumeThreshold)\n      ? options.volumeThreshold\n      : 0;\n    this[WARMING_UP] = options.allowWarmUp === true;\n\n    // The user can pass in a Status object to initialize the Status/stats\n    if (this.options.status) {\n      // Do a check that this is a Status Object,\n      if (this.options.status instanceof Status) {\n        this[STATUS] = this.options.status;\n      } else {\n        this[STATUS] = new Status({ stats: this.options.status });\n      }\n    } else {\n      this[STATUS] = new Status(this.options);\n    }\n\n    this[STATE] = CLOSED;\n\n    if (options.state) {\n      this[ENABLED] = options.state.enabled !== false;\n      this[WARMING_UP] = options.state.warmUp || this[WARMING_UP];\n      // Closed if nothing is passed in\n      this[CLOSED] = options.state.closed !== false;\n      // These should be in sync\n      this[HALF_OPEN] = this[PENDING_CLOSE] = options.state.halfOpen || false;\n      // Open should be the opposite of closed,\n      // but also the opposite of half_open\n      this[OPEN] = !this[CLOSED] && !this[HALF_OPEN];\n      this[SHUTDOWN] = options.state.shutdown || false;\n    } else {\n      this[PENDING_CLOSE] = false;\n      this[ENABLED] = options.enabled !== false;\n    }\n\n    this[FALLBACK_FUNCTION] = null;\n    this[NAME] = options.name || action.name || nextName();\n    this[GROUP] = options.group || this[NAME];\n\n    if (this[WARMING_UP]) {\n      const timer = this[WARMUP_TIMEOUT] = setTimeout(\n        _ => (this[WARMING_UP] = false),\n        this.options.rollingCountTimeout\n      );\n      if (typeof timer.unref === 'function') {\n        timer.unref();\n      }\n    }\n\n    if (typeof action !== 'function') {\n      this.action = _ => Promise.resolve(action);\n    } else this.action = action;\n\n    if (options.maxFailures) console.error(deprecation);\n\n    const increment = property =>\n      (result, runTime) => this[STATUS].increment(property, runTime);\n\n    this.on('success', increment('successes'));\n    this.on('failure', increment('failures'));\n    this.on('fallback', increment('fallbacks'));\n    this.on('timeout', increment('timeouts'));\n    this.on('fire', increment('fires'));\n    this.on('reject', increment('rejects'));\n    this.on('cacheHit', increment('cacheHits'));\n    this.on('cacheMiss', increment('cacheMisses'));\n    this.on('coalesceCacheHit', increment('coalesceCacheHits'));\n    this.on('coalesceCacheMiss', increment('coalesceCacheMisses'));\n    this.on('open', _ => this[STATUS].open());\n    this.on('close', _ => this[STATUS].close());\n    this.on('semaphoreLocked', increment('semaphoreRejections'));\n\n    /**\n     * @param {CircuitBreaker} circuit This current circuit\n     * @returns {function(): void} A bound reset callback\n     * @private\n     */\n    function _startTimer (circuit) {\n      circuit[LAST_TIMER_AT] = Date.now();\n      return _ => {\n        const timer = circuit[RESET_TIMEOUT] = setTimeout(() => {\n          _halfOpen(circuit);\n        }, circuit.options.resetTimeout);\n        if (typeof timer.unref === 'function') {\n          timer.unref();\n        }\n      };\n    }\n\n    /**\n     * Sets the circuit breaker to half open\n     * @private\n     * @param {CircuitBreaker} circuit The current circuit breaker\n     * @returns {void}\n     */\n    function _halfOpen (circuit) {\n      circuit[STATE] = HALF_OPEN;\n      circuit[PENDING_CLOSE] = true;\n      circuit._renewAbortControllerIfNeeded();\n      /**\n       * Emitted after `options.resetTimeout` has elapsed, allowing for\n       * a single attempt to call the service again. If that attempt is\n       * successful, the circuit will be closed. Otherwise it remains open.\n       *\n       * @event CircuitBreaker#halfOpen\n       * @type {Number} how long the circuit remained open\n       */\n      circuit.emit('halfOpen', circuit.options.resetTimeout);\n    }\n\n    this.on('open', _startTimer(this));\n    this.on('success', _ => {\n      if (this.halfOpen) {\n        this.close();\n      }\n    });\n\n    // Prepopulate the State of the Breaker\n    if (this[SHUTDOWN]) {\n      this[STATE] = SHUTDOWN;\n      this.shutdown();\n    } else if (this[CLOSED]) {\n      this.close();\n    } else if (this[OPEN]) {\n      // If the state being passed in is OPEN but more time has elapsed\n      // than the resetTimeout, then we should be in halfOpen state\n      if (this.options.state.lastTimerAt !== undefined &&\n        (Date.now() - this.options.state.lastTimerAt) >\n        this.options.resetTimeout) {\n        _halfOpen(this);\n      } else {\n        this.open();\n      }\n    } else if (this[HALF_OPEN]) {\n      // Not sure if anything needs to be done here\n      this[STATE] = HALF_OPEN;\n    }\n  }\n\n  /**\n   * Renews the abort controller if needed\n   * @private\n   * @returns {void}\n   */\n  _renewAbortControllerIfNeeded () {\n    if (\n      this.options.autoRenewAbortController &&\n        this.options.abortController &&\n        this.options.abortController.signal.aborted\n    ) {\n      this.options.abortController = new AbortController();\n    }\n  }\n\n  /**\n   * Closes the breaker, allowing the action to execute again\n   * @fires CircuitBreaker#close\n   * @returns {void}\n   */\n  close () {\n    if (this[STATE] !== CLOSED) {\n      if (this[RESET_TIMEOUT]) {\n        clearTimeout(this[RESET_TIMEOUT]);\n      }\n      this[STATE] = CLOSED;\n      this[PENDING_CLOSE] = false;\n      this._renewAbortControllerIfNeeded();\n      /**\n       * Emitted when the breaker is reset allowing the action to execute again\n       * @event CircuitBreaker#close\n       */\n      this.emit('close');\n    }\n  }\n\n  /**\n   * Opens the breaker. Each time the breaker is fired while the circuit is\n   * opened, a failed Promise is returned, or if any fallback function\n   * has been provided, it is invoked.\n   *\n   * If the breaker is already open this call does nothing.\n   * @fires CircuitBreaker#open\n   * @returns {void}\n   */\n  open () {\n    if (this[STATE] !== OPEN) {\n      this[STATE] = OPEN;\n      this[PENDING_CLOSE] = false;\n      /**\n       * Emitted when the breaker opens because the action has\n       * failure percentage greater than `options.errorThresholdPercentage`.\n       * @event CircuitBreaker#open\n       */\n      this.emit('open');\n    }\n  }\n\n  /**\n   * Shuts down this circuit breaker. All subsequent calls to the\n   * circuit will fail, returning a rejected promise.\n   * @returns {void}\n   */\n  shutdown () {\n    /**\n     * Emitted when the circuit breaker has been shut down.\n     * @event CircuitBreaker#shutdown\n     */\n    this.emit('shutdown');\n\n    this.disable();\n    this.removeAllListeners();\n    if (this[RESET_TIMEOUT]) {\n      clearTimeout(this[RESET_TIMEOUT]);\n    }\n    if (this[WARMUP_TIMEOUT]) {\n      clearTimeout(this[WARMUP_TIMEOUT]);\n    }\n    this.status.shutdown();\n    this[STATE] = SHUTDOWN;\n\n    // clear cache on shutdown\n    this.clearCache();\n  }\n\n  /**\n   * Determines if the circuit has been shutdown.\n   * @type {Boolean}\n   */\n  get isShutdown () {\n    return this[STATE] === SHUTDOWN;\n  }\n\n  /**\n   * Gets the name of this circuit\n   * @type {String}\n   */\n  get name () {\n    return this[NAME];\n  }\n\n  /**\n   * Gets the name of this circuit group\n   * @type {String}\n   */\n  get group () {\n    return this[GROUP];\n  }\n\n  /**\n   * Gets whether this circuit is in the `pendingClosed` state\n   * @type {Boolean}\n   */\n  get pendingClose () {\n    return this[PENDING_CLOSE];\n  }\n\n  /**\n   * True if the circuit is currently closed. False otherwise.\n   * @type {Boolean}\n   */\n  get closed () {\n    return this[STATE] === CLOSED;\n  }\n\n  /**\n   * True if the circuit is currently opened. False otherwise.\n   * @type {Boolean}\n   */\n  get opened () {\n    return this[STATE] === OPEN;\n  }\n\n  /**\n   * True if the circuit is currently half opened. False otherwise.\n   * @type {Boolean}\n   */\n  get halfOpen () {\n    return this[STATE] === HALF_OPEN;\n  }\n\n  /**\n   * The current {@link Status} of this {@link CircuitBreaker}\n   * @type {Status}\n   */\n  get status () {\n    return this[STATUS];\n  }\n\n  /**\n   * Get the current stats for the circuit.\n   * @see Status#stats\n   * @type {Object}\n   */\n  get stats () {\n    return this[STATUS].stats;\n  }\n\n  toJSON () {\n    return {\n      state: {\n        name: this.name,\n        enabled: this.enabled,\n        closed: this.closed,\n        open: this.opened,\n        halfOpen: this.halfOpen,\n        warmUp: this.warmUp,\n        shutdown: this.isShutdown,\n        lastTimerAt: this[LAST_TIMER_AT]\n      },\n      status: this.status.stats\n    };\n  }\n\n  /**\n   * Gets whether the circuit is enabled or not\n   * @type {Boolean}\n   */\n  get enabled () {\n    return this[ENABLED];\n  }\n\n  /**\n   * Gets whether the circuit is currently in warm up phase\n   * @type {Boolean}\n   */\n  get warmUp () {\n    return this[WARMING_UP];\n  }\n\n  /**\n   * Gets the volume threshold for this circuit\n   * @type {Boolean}\n   */\n  get volumeThreshold () {\n    return this[VOLUME_THRESHOLD];\n  }\n\n  /**\n   * Provide a fallback function for this {@link CircuitBreaker}. This\n   * function will be executed when the circuit is `fire`d and fails.\n   * It will always be preceded by a `failure` event, and `breaker.fire` returns\n   * a rejected Promise.\n   * @param {Function | CircuitBreaker} func the fallback function to execute\n   * when the breaker has opened or when a timeout or error occurs.\n   * @return {CircuitBreaker} this\n   */\n  fallback (func) {\n    let fb = func;\n    if (func instanceof CircuitBreaker) {\n      fb = (...args) => func.fire(...args);\n    }\n    this[FALLBACK_FUNCTION] = fb;\n    return this;\n  }\n\n  /**\n   * Execute the action for this circuit. If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * Any parameters passed to this function will be proxied to the circuit\n   * function.\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action. Use isOurError()\n   * to determine if a rejection was a result of the circuit breaker or the\n   * action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n  fire (...args) {\n    return this.call(this.action, ...args);\n  }\n\n  /**\n   * Execute the action for this circuit using `context` as `this`.\n   * If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * Any parameters in addition to `context will be passed to the\n   * circuit function.\n   *\n   * @param {any} context the `this` context used for function execution\n   * @param {any} rest the arguments passed to the action\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n  call (context, ...rest) {\n    if (this.isShutdown) {\n      const err = buildError('The circuit has been shutdown.', 'ESHUTDOWN');\n      return Promise.reject(err);\n    }\n\n    const args = rest.slice();\n\n    /**\n     * Emitted when the circuit breaker action is executed\n     * @event CircuitBreaker#fire\n     * @type {any} the arguments passed to the fired function\n     */\n    this.emit('fire', args);\n\n    // Protection, caches and coalesce disabled.\n    if (!this[ENABLED]) {\n      const result = this.action.apply(context, args);\n      return (typeof result.then === 'function')\n        ? result\n        : Promise.resolve(result);\n    }\n\n    // Generate cachekey only when cache and/or coalesce is enabled.\n    const cacheKey = this.options.cache || this.options.coalesce ? this.options.cacheGetKey.apply(this, rest) : '';\n\n    // If cache is enabled, check if we have a cached value\n    if (this.options.cache) {\n      const cached = this.options.cacheTransport.get(cacheKey);\n      if (cached) {\n        /**\n         * Emitted when the circuit breaker is using the cache\n         * and finds a value.\n         * @event CircuitBreaker#cacheHit\n         */\n        this.emit('cacheHit');\n        return cached;\n      }\n      /**\n       * Emitted when the circuit breaker does not find a value in\n       * the cache, but the cache option is enabled.\n       * @event CircuitBreaker#cacheMiss\n       */\n      this.emit('cacheMiss');\n    }\n\n    /* When coalesce is enabled, check coalesce cache and return\n     promise, if any. */\n    if (this.options.coalesce) {\n      const cachedCall = this.options.coalesceCache.get(cacheKey);\n\n      if (cachedCall) {\n        /**\n         * Emitted when the circuit breaker is using coalesce cache\n         * and finds a cached promise.\n         * @event CircuitBreaker#coalesceCacheHit\n         */\n        this.emit('coalesceCacheHit');\n        return cachedCall;\n      }\n      /**\n       * Emitted when the circuit breaker does not find a value in\n       * coalesce cache, but the coalesce option is enabled.\n       * @event CircuitBreaker#coalesceCacheMiss\n       */\n      this.emit('coalesceCacheMiss');\n    }\n\n    if (!this.closed && !this.pendingClose) {\n      /**\n       * Emitted when the circuit breaker is open and failing fast\n       * @event CircuitBreaker#reject\n       * @type {Error}\n       */\n      const error = buildError('Breaker is open', 'EOPENBREAKER');\n\n      this.emit('reject', error);\n\n      return fallback(this, error, args) ||\n        Promise.reject(error);\n    }\n    this[PENDING_CLOSE] = false;\n\n    let timeout;\n    let timeoutError = false;\n\n    const call = new Promise((resolve, reject) => {\n      const latencyStartTime = Date.now();\n      if (this.semaphore.test()) {\n        if (this.options.timeout) {\n          timeout = setTimeout(\n            () => {\n              timeoutError = true;\n              const error = buildError(\n                `Timed out after ${this.options.timeout}ms`, 'ETIMEDOUT'\n              );\n              const latency = Date.now() - latencyStartTime;\n              this.semaphore.release();\n              /**\n               * Emitted when the circuit breaker action takes longer than\n               * `options.timeout`\n               * @event CircuitBreaker#timeout\n               * @type {Error}\n               */\n              this.emit('timeout', error, latency, args);\n              handleError(error, this, timeout, args, latency, resolve, reject);\n              resetCoalesce(this, cacheKey, 'timeout');\n\n              if (this.options.abortController) {\n                this.options.abortController.abort();\n              }\n            }, this.options.timeout);\n        }\n\n        try {\n          const result = this.action.apply(context, args);\n          const promise = (typeof result.then === 'function')\n            ? result\n            : Promise.resolve(result);\n\n          promise.then(result => {\n            if (!timeoutError) {\n              clearTimeout(timeout);\n              /**\n               * Emitted when the circuit breaker action succeeds\n               * @event CircuitBreaker#success\n               * @type {any} the return value from the circuit\n               */\n              this.emit('success', result, (Date.now() - latencyStartTime));\n              resetCoalesce(this, cacheKey, 'success');\n              this.semaphore.release();\n              resolve(result);\n              if (this.options.cache) {\n                this.options.cacheTransport.set(\n                  cacheKey,\n                  promise,\n                  this.options.cacheTTL > 0\n                    ? Date.now() + this.options.cacheTTL\n                    : 0\n                );\n              }\n            }\n          })\n            .catch(error => {\n              if (!timeoutError) {\n                this.semaphore.release();\n                const latencyEndTime = Date.now() - latencyStartTime;\n                handleError(\n                  error, this, timeout, args, latencyEndTime, resolve, reject);\n                resetCoalesce(this, cacheKey, 'error');\n              }\n            });\n        } catch (error) {\n          this.semaphore.release();\n          const latency = Date.now() - latencyStartTime;\n          handleError(error, this, timeout, args, latency, resolve, reject);\n          resetCoalesce(this, cacheKey, 'error');\n        }\n      } else {\n        const latency = Date.now() - latencyStartTime;\n        const err = buildError('Semaphore locked', 'ESEMLOCKED');\n        /**\n         * Emitted when the rate limit has been reached and there\n         * are no more locks to be obtained.\n         * @event CircuitBreaker#semaphoreLocked\n         * @type {Error}\n         */\n        this.emit('semaphoreLocked', err, latency);\n        handleError(err, this, timeout, args, latency, resolve, reject);\n        resetCoalesce(this, cacheKey);\n      }\n    });\n\n    /* When coalesce is enabled, store promise in coalesceCache */\n    if (this.options.coalesce) {\n      this.options.coalesceCache.set(\n        cacheKey,\n        call,\n        this.options.coalesceTTL > 0\n          ? Date.now() + this.options.coalesceTTL\n          : 0\n      );\n    }\n\n    return call;\n  }\n\n  /**\n   * Clears the cache of this {@link CircuitBreaker}\n   * @returns {void}\n   */\n  clearCache () {\n    if (this.options.cache) {\n      this.options.cacheTransport.flush();\n    }\n\n    if (this.options.coalesceCache) {\n      this.options.coalesceCache.flush();\n    }\n  }\n\n  /**\n   * Provide a health check function to be called periodically. The function\n   * should return a Promise. If the promise is rejected the circuit will open.\n   * This is in addition to the existing circuit behavior as defined by\n   * `options.errorThresholdPercentage` in the constructor. For example, if the\n   * health check function provided here always returns a resolved promise, the\n   * circuit can still trip and open if there are failures exceeding the\n   * configured threshold. The health check function is executed within the\n   * circuit breaker's execution context, so `this` within the function is the\n   * circuit breaker itself.\n   *\n   * @param {Function} func a health check function which returns a promise.\n   * @param {Number} [interval] the amount of time between calls to the health\n   * check function. Default: 5000 (5 seconds)\n   *\n   * @returns {void}\n   *\n   * @fires CircuitBreaker#healthCheckFailed\n   * @throws {TypeError} if `interval` is supplied but not a number\n   */\n  healthCheck (func, interval) {\n    interval = interval || 5000;\n    if (typeof func !== 'function') {\n      throw new TypeError('Health check function must be a function');\n    }\n    if (isNaN(interval)) {\n      throw new TypeError('Health check interval must be a number');\n    }\n\n    const check = _ => {\n      func.apply(this).catch(e => {\n        /**\n         * Emitted with the user-supplied health check function\n         * returns a rejected promise.\n         * @event CircuitBreaker#healthCheckFailed\n         * @type {Error}\n         */\n        this.emit('healthCheckFailed', e);\n        this.open();\n      });\n    };\n\n    const timer = setInterval(check, interval);\n    if (typeof timer.unref === 'function') {\n      timer.unref();\n    }\n\n    check();\n  }\n\n  /**\n   * Enables this circuit. If the circuit is the  disabled\n   * state, it will be re-enabled. If not, this is essentially\n   * a noop.\n   * @returns {void}\n   */\n  enable () {\n    this[ENABLED] = true;\n    this.status.startListeneningForRotateEvent();\n  }\n\n  /**\n   * Disables this circuit, causing all calls to the circuit's function\n   * to be executed without circuit or fallback protection.\n   * @returns {void}\n   */\n  disable () {\n    this[ENABLED] = false;\n    this.status.removeRotateBucketControllerListener();\n  }\n\n  /**\n   * Retrieves the current AbortSignal from the abortController, if available.\n   * This signal can be used to monitor ongoing requests.\n   * @returns {AbortSignal|undefined} The AbortSignal if present,\n   * otherwise undefined.\n   */\n  getSignal () {\n    if (this.options.abortController && this.options.abortController.signal) {\n      return this.options.abortController.signal;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Retrieves the current AbortController instance.\n   * This controller can be used to manually abort ongoing requests or create\n   * a new signal.\n   * @returns {AbortController|undefined} The AbortController if present,\n   * otherwise undefined.\n   */\n  getAbortController () {\n    return this.options.abortController;\n  }\n}\n\nfunction handleError (error, circuit, timeout, args, latency, resolve, reject) {\n  clearTimeout(timeout);\n\n  if (circuit.options.errorFilter(error, ...args)) {\n    // The error was filtered, so emit 'success'\n    circuit.emit('success', error, latency);\n  } else {\n    // Error was not filtered, so emit 'failure'\n    fail(circuit, error, args, latency);\n\n    // Only call the fallback function if errorFilter doesn't succeed\n    // If the fallback function succeeds, resolve\n    const fb = fallback(circuit, error, args);\n    if (fb) return resolve(fb);\n  }\n\n  // In all other cases, reject\n  reject(error);\n}\n\nfunction fallback (circuit, err, args) {\n  if (circuit[FALLBACK_FUNCTION]) {\n    try {\n      const result =\n      circuit[FALLBACK_FUNCTION]\n        .apply(circuit[FALLBACK_FUNCTION], [...args, err]);\n      /**\n       * Emitted when the circuit breaker executes a fallback function\n       * @event CircuitBreaker#fallback\n       * @type {any} the return value of the fallback function\n       */\n      circuit.emit('fallback', result, err);\n      if (result instanceof Promise) return result;\n      return Promise.resolve(result);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}\n\nfunction fail (circuit, err, args, latency) {\n  /**\n   * Emitted when the circuit breaker action fails\n   * @event CircuitBreaker#failure\n   * @type {Error}\n   */\n  circuit.emit('failure', err, latency, args);\n  if (circuit.warmUp) return;\n\n  // check stats to see if the circuit should be opened\n  const stats = circuit.stats;\n  if ((stats.fires < circuit.volumeThreshold) && !circuit.halfOpen) return;\n  const errorRate = stats.failures / stats.fires * 100;\n  if (errorRate > circuit.options.errorThresholdPercentage ||\n    circuit.halfOpen) {\n    circuit.open();\n  }\n}\n\nfunction resetCoalesce (circuit, cacheKey, event) {\n/**\n * Reset coalesce cache for this cacheKey, depending on\n * options.coalesceResetOn set.\n * @param {@link CircuitBreaker} circuit what circuit is to be cleared\n * @param {string} cacheKey cache key to clear.\n * @param {string} event optional, can be `error`, `success`, `timeout`\n * @returns {void}\n */\n  if (!event || circuit.options.coalesceResetOn.includes(event)) {\n    circuit.options.coalesceCache?.delete(cacheKey);\n  }\n}\n\nfunction buildError (msg, code) {\n  const error = new Error(msg);\n  error.code = code;\n  error[OUR_ERROR] = true;\n  return error;\n}\n\n// http://stackoverflow.com/a/2117523\nconst nextName = () =>\n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n\nmodule.exports = exports = CircuitBreaker;\n","/**\n * Simple in-memory cache implementation\n * @class MemoryCache\n * @property {Map} cache Cache map\n */\nclass MemoryCache {\n  constructor (maxEntries) {\n    this.cache = new Map();\n    this.maxEntries = maxEntries ?? 2 ** 24 - 1; // Max size for Map is 2^24.\n  }\n\n  /**\n   * Get cache value by key\n   * @param {string} key Cache key\n   * @return {any} Response from cache\n   */\n  get (key) {\n    const cached = this.cache.get(key);\n    if (cached) {\n      if (cached.expiresAt > Date.now() || cached.expiresAt === 0) {\n        return cached.value;\n      }\n      this.cache.delete(key);\n    }\n    return undefined;\n  }\n\n  /**\n   * Set cache key with value and ttl\n   * @param {string} key Cache key\n   * @param {any} value Value to cache\n   * @param {number} ttl Time to live in milliseconds\n   * @return {void}\n   */\n  set (key, value, ttl) {\n    // Evict first entry when at capacity - only when it's a new key.\n    if (this.cache.size === this.maxEntries && this.get(key) === undefined) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n\n    this.cache.set(key, {\n      expiresAt: ttl,\n      value\n    });\n  }\n\n  /**\n   * Delete cache key\n   * @param {string} key Cache key\n   * @return {void}\n   */\n  delete (key) {\n    this.cache.delete(key);\n  }\n\n  /**\n   * Clear cache\n   * @returns {void}\n   */\n  flush () {\n    this.cache.clear();\n  }\n}\n\nmodule.exports = exports = MemoryCache;\n","'use strict';\n\nmodule.exports = exports = require('./lib/circuit');\n","'use strict';\n\nconst WINDOW = Symbol('window');\nconst BUCKETS = Symbol('buckets');\nconst TIMEOUT = Symbol('timeout');\nconst PERCENTILES = Symbol('percentiles');\nconst BUCKET_INTERVAL = Symbol('bucket-interval');\nconst SNAPSHOT_INTERVAL = Symbol('snapshot-interval');\nconst ROTATE_EVENT_NAME = Symbol('rotate-event-name');\n\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Tracks execution status for a given {@link CircuitBreaker}.\n * A Status instance is created for every {@link CircuitBreaker}\n * and does not typically need to be created by a user.\n *\n * A Status instance will listen for all events on the {@link CircuitBreaker}\n * and track them in a rolling statistical window. The window duration is\n * determined by the `rollingCountTimeout` option provided to the\n * {@link CircuitBreaker}. The window consists of an array of Objects,\n * each representing the counts for a {@link CircuitBreaker}'s events.\n *\n * The array's length is determined by the {@link CircuitBreaker}'s\n * `rollingCountBuckets` option. The duration of each slice of the window\n * is determined by dividing the `rollingCountTimeout` by\n * `rollingCountBuckets`.\n *\n * @class Status\n * @extends EventEmitter\n * @param {Object} options for the status window\n * @param {Number} options.rollingCountBuckets number of buckets in the window\n * @param {Number} options.rollingCountTimeout the duration of the window\n * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n * percentiles\n * @param {Object} options.stats object of previous stats\n * @example\n * // Creates a 1 second window consisting of ten time slices,\n * // each 100ms long.\n * const circuit = circuitBreaker(fs.readFile,\n *  { rollingCountBuckets: 10, rollingCountTimeout: 1000});\n *\n * // get the cumulative statistics for the last second\n * circuit.status.stats;\n *\n * // get the array of 10, 1 second time slices for the last second\n * circuit.status.window;\n * @fires Status#snapshot\n * @see CircuitBreaker#status\n */\nclass Status extends EventEmitter {\n  constructor (options) {\n    super();\n\n    // Set up our statistical rolling window\n    this[BUCKETS] = options.rollingCountBuckets || 10;\n    this[TIMEOUT] = options.rollingCountTimeout || 10000;\n    this[WINDOW] = new Array(this[BUCKETS]);\n    this[PERCENTILES] = [0.0, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.995, 1];\n    this[ROTATE_EVENT_NAME] = 'rotate';\n\n    // Default this value to true\n    this.rollingPercentilesEnabled =\n    options.rollingPercentilesEnabled !== false;\n\n    // Default this value to true\n    this.enableSnapshots = options.enableSnapshots !== false;\n\n    // can be undefined\n    this.rotateBucketController = options.rotateBucketController;\n    this.rotateBucket = nextBucket(this[WINDOW]);\n\n    // prime the window with buckets\n    for (let i = 0; i < this[BUCKETS]; i++) this[WINDOW][i] = bucket();\n\n    const bucketInterval = Math.floor(this[TIMEOUT] / this[BUCKETS]);\n\n    if (this.rotateBucketController) {\n      // rotate the buckets based on an optional EventEmitter\n      this.startListeneningForRotateEvent();\n    } else {\n      // or rotate the buckets periodically\n      this[BUCKET_INTERVAL] = setInterval(this.rotateBucket, bucketInterval);\n      // No unref() in the browser\n      if (typeof this[BUCKET_INTERVAL].unref === 'function') {\n        this[BUCKET_INTERVAL].unref();\n      }\n    }\n\n    /**\n     * Emitted at each time-slice. Listeners for this\n     * event will receive a cumulative snapshot of the current status window.\n     * @event Status#snapshot\n     * @type {Object}\n     */\n    if (this.enableSnapshots) {\n      this[SNAPSHOT_INTERVAL] = setInterval(\n        _ => this.emit('snapshot', this.stats),\n        bucketInterval);\n      if (typeof this[SNAPSHOT_INTERVAL].unref === 'function') {\n        this[SNAPSHOT_INTERVAL].unref();\n      }\n    }\n\n    if (options.stats) {\n      this[WINDOW][0] = { ...bucket(), ...options.stats };\n    }\n  }\n\n  /**\n   * Get the cumulative stats for the current window\n   * @type {Object}\n   */\n  get stats () {\n    const totals = this[WINDOW].reduce((acc, val) => {\n      if (!val) { return acc; }\n      Object.keys(acc).forEach(key => {\n        if (key !== 'latencyTimes' && key !== 'percentiles') {\n          (acc[key] += val[key] || 0);\n        }\n      });\n\n      if (this.rollingPercentilesEnabled) {\n        if (val.latencyTimes) {\n          acc.latencyTimes = acc.latencyTimes.concat(val.latencyTimes);\n        }\n      }\n      return acc;\n    }, bucket());\n\n    if (this.rollingPercentilesEnabled) {\n      // Sort the latencyTimes\n      totals.latencyTimes.sort((a, b) => a - b);\n\n      // Get the mean latency\n      // Mean = sum of all values in the array/length of array\n      if (totals.latencyTimes.length) {\n        totals.latencyMean =\n          (totals\n            .latencyTimes\n            .reduce((a, b) => a + b, 0)) / totals.latencyTimes.length;\n      } else {\n        totals.latencyMean = 0;\n      }\n\n      // Calculate Percentiles\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] =\n          calculatePercentile(percentile, totals.latencyTimes);\n      });\n    } else {\n      totals.latencyMean = -1;\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] = -1;\n      });\n    }\n\n    return totals;\n  }\n\n  /**\n   * Gets the stats window as an array of time-sliced objects.\n   * @type {Array}\n   */\n  get window () {\n    return this[WINDOW].slice();\n  }\n\n  increment (property, latencyRunTime) {\n    this[WINDOW][0][property]++;\n    if (property === 'successes' ||\n        property === 'failures' ||\n        property === 'timeouts') {\n      this[WINDOW][0].latencyTimes.push(latencyRunTime || 0);\n    }\n  }\n\n  open () {\n    this[WINDOW][0].isCircuitBreakerOpen = true;\n  }\n\n  close () {\n    this[WINDOW][0].isCircuitBreakerOpen = false;\n  }\n\n  shutdown () {\n    this.removeAllListeners();\n    // interval is not set if rotateBucketController is provided\n    if (this.rotateBucketController === undefined) {\n      clearInterval(this[BUCKET_INTERVAL]);\n    } else {\n      this.removeRotateBucketControllerListener();\n    }\n    if (this.enableSnapshots) {\n      clearInterval(this[SNAPSHOT_INTERVAL]);\n    }\n  }\n\n  removeRotateBucketControllerListener () {\n    if (this.rotateBucketController) {\n      this.rotateBucketController.removeListener(this[ROTATE_EVENT_NAME],\n        this.rotateBucket);\n    }\n  }\n\n  startListeneningForRotateEvent () {\n    if (\n      this.rotateBucketController &&\n      this.rotateBucketController.listenerCount(this[ROTATE_EVENT_NAME],\n        this.rotateBucket) === 0\n    ) {\n      this.rotateBucketController.on(this[ROTATE_EVENT_NAME],\n        this.rotateBucket);\n    }\n  }\n}\n\nconst nextBucket = window => _ => {\n  window.pop();\n  window.unshift(bucket());\n};\n\nconst bucket = _ => ({\n  failures: 0,\n  fallbacks: 0,\n  successes: 0,\n  rejects: 0,\n  fires: 0,\n  timeouts: 0,\n  cacheHits: 0,\n  cacheMisses: 0,\n  coalesceCacheHits: 0,\n  coalesceCacheMisses: 0,\n  semaphoreRejections: 0,\n  percentiles: {},\n  latencyTimes: []\n});\n\nfunction calculatePercentile (percentile, arr) {\n  if (percentile === 0) {\n    return arr[0] || 0;\n  }\n  const idx = Math.ceil(percentile * arr.length);\n  return arr[idx - 1] || 0;\n}\n\nmodule.exports = exports = Status;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(660);\n"],"names":["root","factory","exports","module","define","amd","self","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","flags","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","resolvers","counter","sem","take","release","test","_","timeout","setTimeout","code","_toConsumableArray","r","isArray","_arrayLikeToArray","_arrayWithoutHoles","Symbol","iterator","from","_iterableToArray","a","t","toString","constructor","_unsupportedIterableToArray","_nonIterableSpread","e","_typeof","o","_defineProperties","configurable","writable","_toPropertyKey","toPrimitive","_toPrimitive","_setPrototypeOf","setPrototypeOf","__proto__","_assertThisInitialized","ReferenceError","_isNativeReflectConstruct","Boolean","valueOf","construct","_getPrototypeOf","require","Status","Semaphore","MemoryCache","STATE","OPEN","CLOSED","HALF_OPEN","PENDING_CLOSE","SHUTDOWN","FALLBACK_FUNCTION","STATUS","NAME","GROUP","ENABLED","WARMING_UP","VOLUME_THRESHOLD","OUR_ERROR","RESET_TIMEOUT","WARMUP_TIMEOUT","LAST_TIMER_AT","CircuitBreaker","_EventEmitter","_inherits","_super","s","_possibleConstructorReturn","_createSuper","action","_options$timeout","_options$resetTimeout","_options$errorThresho","_options$rollingCount","_options$rollingCount2","_options$cacheTTL","_options$cacheGetKey","_options$coalesceTTL","_options$coalesceRese","_this","options","_classCallCheck","resetTimeout","errorThresholdPercentage","rollingCountTimeout","rollingCountBuckets","rollingPercentilesEnabled","capacity","isInteger","MAX_SAFE_INTEGER","errorFilter","cacheTTL","cacheGetKey","_len","_key","JSON","stringify","enableSnapshots","rotateBucketController","coalesce","coalesceTTL","coalesceResetOn","filter","includes","cache","cacheTransport","cacheSize","flush","coalesceCache","coalesceSize","semaphore","autoRenewAbortController","abortController","AbortController","abort","volumeThreshold","allowWarmUp","status","stats","enabled","warmUp","closed","halfOpen","shutdown","nextName","group","timer","unref","maxFailures","circuit","increment","property","result","runTime","_halfOpen","_renewAbortControllerIfNeeded","open","close","Date","now","lastTimerAt","signal","aborted","clearTimeout","disable","clearCache","opened","isShutdown","func","fb","fire","_len2","_key2","_this2","buildError","_len3","rest","_key3","then","cacheKey","cached","cachedCall","pendingClose","fallback","timeoutError","latencyStartTime","latency","handleError","resetCoalesce","promise","latencyEndTime","interval","_this3","check","setInterval","startListeneningForRotateEvent","removeRotateBucketControllerListener","_circuit$options","fires","failures","fail","event","_circuit$options$coal","msg","replace","c","Math","random","maxEntries","Map","pow","expiresAt","ttl","size","next","clear","getOwnPropertyDescriptor","_objectSpread","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","WINDOW","BUCKETS","TIMEOUT","PERCENTILES","BUCKET_INTERVAL","SNAPSHOT_INTERVAL","ROTATE_EVENT_NAME","rotateBucket","nextBucket","bucket","bucketInterval","floor","totals","reduce","acc","val","latencyTimes","sort","b","latencyMean","percentile","percentiles","ceil","calculatePercentile","latencyRunTime","isCircuitBreakerOpen","clearInterval","window","fallbacks","successes","rejects","timeouts","cacheHits","cacheMisses","coalesceCacheHits","coalesceCacheMisses","semaphoreRejections","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}